<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silverlaw&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.silverlaw.top/"/>
  <updated>2019-10-29T08:02:09.988Z</updated>
  <id>https://blog.silverlaw.top/</id>
  
  <author>
    <name>silverlaw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 下扩展磁盘分区</title>
    <link href="https://blog.silverlaw.top/2019/10/29/linux-%E6%89%A9%E5%B1%95%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    <id>https://blog.silverlaw.top/2019/10/29/linux-扩展磁盘分区/</id>
    <published>2019-10-29T06:00:35.000Z</published>
    <updated>2019-10-29T08:02:09.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扩展指定的磁盘分区"><a href="#扩展指定的磁盘分区" class="headerlink" title="扩展指定的磁盘分区"></a>扩展指定的磁盘分区</h2><h3 id="首先查看当前系统的磁盘和分区大小"><a href="#首先查看当前系统的磁盘和分区大小" class="headerlink" title="首先查看当前系统的磁盘和分区大小"></a>首先查看当前系统的磁盘和分区大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 查看所有的磁盘和分区大小</span><br><span class="line">[root@localhost /]# lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0 29.8G  0 disk </span><br><span class="line">└─sda1   8:1    0 23.4G  0 part /</span><br><span class="line">sdb      8:16   0  3.7T  0 disk </span><br><span class="line">├─sdb1   8:17   0   32G  0 part </span><br><span class="line">└─sdb2   8:18   0  3.6T  0 part</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//  查看当前文件系统的使用量</span><br><span class="line">[root@localhost /]# df -h</span><br><span class="line">文件系统         容量  已用  可用  已用% 挂载点</span><br><span class="line">/dev/root        19G   18G     0  100% /</span><br><span class="line">devtmpfs         16G     0   16G    0% /dev</span><br><span class="line">tmpfs            16G     0   16G    0% /dev/shm</span><br><span class="line">tmpfs            16G   16M   16G    1% /run</span><br><span class="line">tmpfs           5.0M     0  5.0M    0% /run/lock</span><br><span class="line">tmpfs            16G     0   16G    0% /sys/fs/cgroup</span><br><span class="line">tmpfs           3.1G     0  3.1G    0% /run/user/0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      我们在使用Linux作为虚拟机进行日常开发工作，经常会遇到某个磁盘空间不足的情况，这种情况下有两种磁盘空间扩容的方法，即当前系统是否创建了逻辑卷。
    
    </summary>
    
      <category term="linux" scheme="https://blog.silverlaw.top/categories/linux/"/>
    
    
      <category term="linux" scheme="https://blog.silverlaw.top/tags/linux/"/>
    
      <category term="分区" scheme="https://blog.silverlaw.top/tags/%E5%88%86%E5%8C%BA/"/>
    
      <category term="parted" scheme="https://blog.silverlaw.top/tags/parted/"/>
    
  </entry>
  
  <entry>
    <title>syslog协议</title>
    <link href="https://blog.silverlaw.top/2019/08/15/syslog%E5%8D%8F%E8%AE%AE/"/>
    <id>https://blog.silverlaw.top/2019/08/15/syslog协议/</id>
    <published>2019-08-15T09:38:00.000Z</published>
    <updated>2019-08-15T10:01:22.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul><li><code>syslog</code>协议属于一种主从式协议，通常被用于信息系统管理及信息安全审核。虽然它有不少缺陷，但仍获得相当多的设备及各种平台的接收端支持。因此<code>syslog</code>能被用来将来自许多不同类型系统的日志记录集成到集中的存储库中。<a id="more"></a>  </li></ul><h2 id="2-协议内容"><a href="#2-协议内容" class="headerlink" title="2. 协议内容"></a>2. 协议内容</h2><ul><li><code>syslog</code>格式为一个长字符串，整个数据报分为三个部分：<code>PRI</code>、<code>HEADER</code>、<code>MSG</code><ul><li><code>PRI</code>:  只能为3、4、5个字符，并且以小于符号开始，以大于符号结束，中间为一个1到3位的数字</li><li><code>HEADER</code>: 由<code>TimeStamp</code>与<code>HostName</code>组成。<code>HEADER</code>部分紧跟<code>PRI</code>，中间没有空格。<code>TimeStamp</code>与<code>HostName</code>之间间隔一个空格。<code>HostName</code>后面紧跟一个空格。<ul><li><code>TimeStamp</code>: 字段使用<code>local time</code>，格式为：<code>Mmm dd hh:mm:ss</code></li><li><code>Mmm</code>: 是英语月份的单词缩写，例如：Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec</li><li><code>dd</code>: 某个月的多少号，固定宽度2个字符，不足两个字符在数字前面用空格填充。</li><li><code>hh:mm:ss</code>: 本地时间<ul><li><code>hh</code>: 24时制的小时，在00-23之间</li><li><code>mm</code>和<code>ss</code>： 分和秒，在00-59之间</li></ul></li><li><code>HostName</code>: 该字段为主机的<code>hostname</code>。该字段后面紧跟一个空格</li></ul></li><li><code>MSG</code>:  该字段又两部分组成： <code>TAG</code>和<code>CONTENT</code><ul><li><code>TAG</code>: 该字段的值为产生日志的程序名，即推送日志到外部系统的程序名（不超过32个字符）。<code>TAG</code>后面紧跟一个用中括号包含着的<code>pid</code>,即<code>[pid]</code>,并且再追加一个<code>:</code>,<code>pid</code>为该推送程序的进程号</li><li><code>CONTENT</code>: 该字段为具体的日志内容</li></ul></li></ul></li><li>综上，整个数据报为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;xxx&gt;Mmm dd hh:mm:ss hostname tag[pid]: xxxxxxxxx</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-rsyslog服务器配置"><a href="#3-rsyslog服务器配置" class="headerlink" title="3. rsyslog服务器配置"></a>3. rsyslog服务器配置</h2><h3 id="3-1-安装syslog服务"><a href="#3-1-安装syslog服务" class="headerlink" title="3.1 安装syslog服务"></a>3.1 安装<code>syslog</code>服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install rsyslog -y</span><br></pre></td></tr></table></figure><h3 id="3-2-修改配置文件"><a href="#3-2-修改配置文件" class="headerlink" title="3.2 修改配置文件"></a>3.2 修改配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ModLoad imudp</span><br><span class="line">$UDPServerRun 514</span><br><span class="line"></span><br><span class="line">$ModLoad imtcp</span><br><span class="line">$InputTCPServerRun 514</span><br><span class="line"></span><br><span class="line">$template RemoteLogs,&quot;/var/log/%HOSTNAME%/%PROGRAMNAME%.log&quot; *</span><br><span class="line">*.*  ?RemoteLogs</span><br><span class="line">&amp; ~</span><br></pre></td></tr></table></figure><h3 id="3-3-启动rsyslog服务生效"><a href="#3-3-启动rsyslog服务生效" class="headerlink" title="3.3 启动rsyslog服务生效"></a>3.3 启动<code>rsyslog</code>服务生效</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rsyslog</span><br></pre></td></tr></table></figure><h2 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4. 参考文献"></a>4. 参考文献</h2>]]></content>
    
    <summary type="html">
    
      syslog协议属于一种主从式协议，通常被用于信息系统管理及信息安全审核。虽然它有不少缺陷，但仍获得相当多的设备及各种平台的接收端支持。因此syslog能被用来将来自许多不同类型系统的日志记录集成到集中的存储库中。
    
    </summary>
    
      <category term="linux" scheme="https://blog.silverlaw.top/categories/linux/"/>
    
    
      <category term="linux" scheme="https://blog.silverlaw.top/tags/linux/"/>
    
      <category term="syslog" scheme="https://blog.silverlaw.top/tags/syslog/"/>
    
      <category term="日志" scheme="https://blog.silverlaw.top/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="协议" scheme="https://blog.silverlaw.top/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>逻辑卷LVM相关操作</title>
    <link href="https://blog.silverlaw.top/2019/08/15/%E9%80%BB%E8%BE%91%E5%8D%B7LVM%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.silverlaw.top/2019/08/15/逻辑卷LVM相关的操作/</id>
    <published>2019-08-15T01:30:30.000Z</published>
    <updated>2019-08-24T04:08:25.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是逻辑卷"><a href="#什么是逻辑卷" class="headerlink" title="什么是逻辑卷"></a>什么是逻辑卷</h2><ul><li>逻辑卷（lv）是将几个磁盘分区或者块设备(pv，pv的id必须是8e的，pv可以位于不同的磁盘分区里，pv大小可以不一)组织起来形成一个大的扩展分区（vg,卷组，一个vg至少要包含一个pv。），该扩展分区不能直接用，需要将其划分成逻辑卷（lv）才能使用，lv可以格式化成不同的文件系统，挂载后直接使用。<a id="more"></a>  </li><li>lv的扩展和缩减是不会影响原有数据的，但逻辑卷缩减的风险大于逻辑卷扩展的风险。</li><li>逻辑卷可以支持快照功能。</li></ul><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li>物理卷（PV, Physical Volume）<ul><li>物理卷就是指磁盘,磁盘分区或从逻辑上和磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有和LVM相关的管理参数。当前LVM允许你在每个物理卷上保存这个物理卷的0至2份元数据拷贝.默认为1,保存在设备的开始处.为2时,在设备结束处保存第二份备份.</li></ul></li></ul><ul><li>卷组（VG, Volume Group）<ul><li>LVM卷组类似于非LVM系统中的物理硬盘，其由物理卷组成。能在卷组上创建一个或多个“LVM分区”（逻辑卷），LVM卷组由一个或多个物理卷组成。</li></ul></li></ul><ul><li>逻辑卷（LV, Logical Volume）<ul><li>LVM的逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷之上能建立文件系统(比如/home或/usr等)。</li></ul></li></ul><ul><li>线性逻辑卷 (Linear Volumes)<ul><li>一个线性逻辑卷聚合多个物理卷成为一个逻辑卷.比如,如果你有两个60GB硬盘,你能生成120GB的逻辑卷.</li></ul></li></ul><ul><li>条块化的逻辑卷(Striped Logical Volumes)<ul><li>当你写数据到此逻辑卷中时,文件系统能将数据放置到多个物理卷中.对于大量连接读写操作,他能改善数据I/O效率.</li></ul></li></ul><ul><li>映像的逻辑卷(Mirrored Logical Volumes)<ul><li>映像在不同的设备上保存一致的数据.数据同时被写入原设备及映像设备.他提供设备之间的容错。</li></ul></li></ul><ul><li><p>快照卷(Snapshot Volumes)</p><ul><li>快照卷提供在特定瞬间的一个设备虚拟映像，当快照开始时，他复制一份对当前数据区域的改动，由于他优先执行这些改动，所以他能重构当前设备的状态。</li></ul></li><li><p>参考: <a href="https://www.cnblogs.com/shxdyz/articles/7834980.html" target="_blank" rel="noopener">https://www.cnblogs.com/shxdyz/articles/7834980.html</a></p></li></ul><h2 id="查看逻辑卷信息"><a href="#查看逻辑卷信息" class="headerlink" title="查看逻辑卷信息"></a>查看逻辑卷信息</h2><h3 id="查看LV"><a href="#查看LV" class="headerlink" title="查看LV"></a>查看LV</h3><ul><li><code>lvscan</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvscan</span><br><span class="line">  ACTIVE            &apos;/dev/VG_BASTION/LV_SWAP&apos; [2.00 GiB] inherit</span><br><span class="line">  ACTIVE            &apos;/dev/VG_BASTION/LV_DATA&apos; [&lt;57.98 GiB] inherit</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看VG"><a href="#查看VG" class="headerlink" title="查看VG"></a>查看VG</h3><ul><li><code>vgscan</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgscan</span><br><span class="line">  Reading volume groups from cache.</span><br><span class="line">  Found volume group &quot;VG_BASTION&quot; using metadata type lvm2</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看PV"><a href="#查看PV" class="headerlink" title="查看PV"></a>查看PV</h3><ul><li><code>pvscan</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvscan</span><br><span class="line">  PV /dev/sdb1   VG VG_BASTION      lvm2 [19.99 GiB / 0    free]</span><br><span class="line">  PV /dev/sdc1   VG VG_BASTION      lvm2 [19.99 GiB / 0    free]</span><br><span class="line">  PV /dev/sdd1   VG VG_BASTION      lvm2 [19.99 GiB / 0    free]</span><br><span class="line">  Total: 3 [&lt;59.98 GiB] / in use: 3 [&lt;59.98 GiB] / in no VG: 0 [0   ]</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建逻辑卷"><a href="#创建逻辑卷" class="headerlink" title="创建逻辑卷"></a>创建逻辑卷</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>再创建逻辑卷时，应当先创建物理卷(pv)，再创建卷组(vg)，最后再创建逻辑卷(lv)</li></ul><h3 id="创建PV"><a href="#创建PV" class="headerlink" title="创建PV"></a>创建PV</h3><ul><li><code>pvcreate</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pvcreate &lt;device&gt;</span><br><span class="line"></span><br><span class="line">// device: 要创建物理卷的设备路径</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">[root@centos6 bash]# pvcreate /dev/sda1 </span><br><span class="line">  Physical volume &quot;/dev/sda1&quot; successfully created</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建VG"><a href="#创建VG" class="headerlink" title="创建VG"></a>创建VG</h3><ul><li><code>vgcreate</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vgcreate &lt;vg_name&gt; &lt;pv list&gt;</span><br><span class="line"></span><br><span class="line">// vg_name: 卷组名</span><br><span class="line">// device list: 要添加到卷组的物理卷pv列表</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">[root@centos6 bash]# vgcreate vg_bastion /dev/sda1 /dev/sdc1 </span><br><span class="line">  Volume group &quot;vg_bastion&quot; successfully created</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改卷组属性"><a href="#修改卷组属性" class="headerlink" title="修改卷组属性"></a>修改卷组属性</h3><ul><li><code>vgchange</code><ul><li>激活卷组: <code>vgchange -ay vg_bastion</code></li></ul></li></ul><h3 id="创建LV"><a href="#创建LV" class="headerlink" title="创建LV"></a>创建LV</h3><ul><li><code>lvcreate</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -n &lt;lv_name&gt; -L &lt;size&gt; &lt;vg_name&gt; -y</span><br><span class="line">lvcreate -n &lt;lv_name&gt; -l &lt;size&gt; &lt;vg_name&gt; -y</span><br><span class="line"></span><br><span class="line">// -L: 指定大小(--size LogicalVolumeSize[bBsSkKmMgGtTpPeE])</span><br><span class="line">// -l: 可以指定百分比(--extents LogicalExtentsNumber[%&#123;VG|FREE|ORIGIN&#125;]),如 100%FREE</span><br><span class="line"></span><br><span class="line">// lv_name: 逻辑卷名</span><br><span class="line">// size： 创建的卷大小</span><br><span class="line">// vg_name: 卷组名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">    lvcreate -n &quot;lv_swap&quot; -L &quot;2GiB&quot; &quot;vg_bastion&quot; -y</span><br><span class="line">    lvcreate -n &quot;lv_data&quot; -l &quot;100%FREE&quot; &quot;vg_bastion&quot; -y</span><br></pre></td></tr></table></figure></li></ul><h2 id="删除逻辑卷"><a href="#删除逻辑卷" class="headerlink" title="删除逻辑卷"></a>删除逻辑卷</h2><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ul><li>在删除逻辑卷之前，应当先卸载掉已经被挂载的分区，然后再进行逻辑卷的删除。<ul><li>在卸载分区时，如果遇到当前分区正在被使用，无法进行卸载的情况，可以借助<code>lsof</code>命令找到正在占用挂载点的进程，然后将其<code>kill</code>掉，再进行卸载在操作。</li></ul></li><li>逻辑卷的删除顺序与创建顺序相反，首先删除逻辑卷(lv)，然后删除卷组(vg)，最后删除物理卷(pv)</li></ul><h3 id="删除LV"><a href="#删除LV" class="headerlink" title="删除LV"></a>删除LV</h3><ul><li><code>lvremove</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvremove /dev/VG_BASTION/LV_SWAP -f -y</span><br><span class="line">  Logical volume &quot;LV_SWAP&quot; successfully removed</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除VG"><a href="#删除VG" class="headerlink" title="删除VG"></a>删除VG</h3><ul><li><code>vgremove</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgremove VG_BASTION -f -y</span><br><span class="line">  Volume group &quot;VG_BASTION&quot; successfully removed</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除PV"><a href="#删除PV" class="headerlink" title="删除PV"></a>删除PV</h3><ul><li><code>pvremove</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvremove /dev/sdb1 -f -y</span><br><span class="line">  Labels on physical volume &quot;/dev/sdb1&quot; successfully wiped.</span><br></pre></td></tr></table></figure></li></ul><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><h3 id="创建磁盘分区"><a href="#创建磁盘分区" class="headerlink" title="创建磁盘分区"></a>创建磁盘分区</h3><ul><li><p>创建分区表,采用 <code>msdos(MBR)</code>或者<code>GPT</code></p><ul><li><code>GPT</code>分区表: <code>parted -s /dev/sdd mklabel gpt</code></li><li><code>MBR</code>分区表: <code>parted -s /dev/sdd mklabel msdos</code></li></ul></li><li><p>创建主分区: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">parted -s &lt;device&gt; mkpart &lt;part-type&gt; [fs-type] start end</span><br><span class="line"></span><br><span class="line">// deice: 指定磁盘设备</span><br><span class="line">// part-type: 只能为 primary(主分区)、logical(逻辑分区)、extended(扩展分区)</span><br><span class="line">// fs-type: 非必填参数,可以为: &quot;btrfs&quot;,  &quot;ext2&quot;,  &quot;ext3&quot;,  &quot;ext4&quot;,  &quot;fat16&quot;,  &quot;fat32&quot;, &quot;hfs&quot;, &quot;hfs+&quot;, &quot;linux-swap&quot;, &quot;ntfs&quot;, &quot;reiserfs&quot;, or &quot;xfs&quot;</span><br><span class="line">// start: 指定分区开始位置，默认为磁盘起始位置</span><br><span class="line">// end: 指定分区结束位置,默认为磁盘结束位置</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">    parted -s /dev/sdd mkpart primary 4MiB 100%   </span><br><span class="line">    // 在 /dev/sdd 上创建一个主分区，从4MiB的位置开始，到磁盘末尾结束</span><br><span class="line">    // 即整个分区大小为 磁盘大小-4MiB</span><br></pre></td></tr></table></figure></li><li><p>修改分区表状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">parted -s &lt;device&gt; toggle &lt;partition_number&gt; &lt;status&gt;</span><br><span class="line"></span><br><span class="line">// device: 指定磁盘设备</span><br><span class="line">// partition_number: 该磁盘设备上的第几个分区</span><br><span class="line">// status: 转换后的状态(raid|lvm)</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">    parted -s /dev/sdd toggle 1 &quot;lvm&quot;</span><br><span class="line">    // 将 /dev/sdd 上的第一个分区标记为 lvm</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除磁盘分区"><a href="#删除磁盘分区" class="headerlink" title="删除磁盘分区"></a>删除磁盘分区</h3><ul><li><p>可以通过<code>parted</code>删除指定的某个分区: <code>parted -s /dev/sdc rm 1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parted -s &lt;device&gt; rm &lt;partition_number&gt;</span><br><span class="line"></span><br><span class="line">// device: 指定磁盘设备</span><br><span class="line">// partition_number: 该磁盘设备上的第几个分区</span><br><span class="line"></span><br><span class="line">示例: </span><br><span class="line">    parted -s /dev/sdc rm 1</span><br><span class="line">    // 删除 /dev/sdc 上的第一个分区</span><br></pre></td></tr></table></figure></li><li><p>一般情况下，如果要摧毁整个磁盘分区，那么只需要将磁盘首部的分区表摧毁掉就行了，所以，可以直接采用<code>dd</code>命令: <code>dd if=/dev/zero of=/dev/sdd bs=16MiB count=1</code></p></li></ul><h3 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h3><ul><li><p>制作交换分区: <code>mkswap</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkswap -f -L &lt;label&gt; &lt;device&gt;</span><br><span class="line"></span><br><span class="line">// device: 指定磁盘设备</span><br><span class="line">// label: 指定交换分区的标签label</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">  mkswap -f -L label_swap /dev/vg_bastion/lv_swap</span><br></pre></td></tr></table></figure></li><li><p>格式化: <code>mkfs</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkfs.&lt;fs&gt; -L &lt;label&gt; &lt;device&gt;</span><br><span class="line"></span><br><span class="line">// fs: 文件系统格式</span><br><span class="line">// device: 指定磁盘设备</span><br><span class="line">// label: 指定交换分区的标签label</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">    mkfs.xfs -L label_data /dev/vg_bastion/lv_data</span><br><span class="line">    mkfs.ext4 -L label_data /dev/vg_bastion/lv_data</span><br><span class="line"></span><br><span class="line">    mkfs -t xfs -L label_data /dev/vg_bastion/lv_data</span><br><span class="line">    mkfs -t ext4 -L label_data /dev/vg_bastion/lv_data</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据无价，操作需谨慎"><a href="#数据无价，操作需谨慎" class="headerlink" title="数据无价，操作需谨慎"></a>数据无价，操作需谨慎</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/solaraceboy/article/details/78539233" target="_blank" rel="noopener">https://blog.csdn.net/solaraceboy/article/details/78539233</a></li><li><a href="https://www.cnblogs.com/shxdyz/articles/7834980.html" target="_blank" rel="noopener">https://www.cnblogs.com/shxdyz/articles/7834980.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      逻辑卷是将几个磁盘分区或者块设备组织起来形成的一个大的扩展分区,该扩展分区不能直接用，需要将其划分成逻辑卷（lv）才能使用，lv可以格式化成不同的文件系统，挂载后直接使用。
    
    </summary>
    
      <category term="linux" scheme="https://blog.silverlaw.top/categories/linux/"/>
    
    
      <category term="linux" scheme="https://blog.silverlaw.top/tags/linux/"/>
    
      <category term="LVM" scheme="https://blog.silverlaw.top/tags/lvm/"/>
    
  </entry>
  
  <entry>
    <title>GRUB与GRUB2的区别</title>
    <link href="https://blog.silverlaw.top/2019/08/14/grub%E4%B8%8Egrub2%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://blog.silverlaw.top/2019/08/14/grub与grub2的区别/</id>
    <published>2019-08-14T07:48:43.000Z</published>
    <updated>2019-08-15T02:04:36.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是GRUB"><a href="#1-什么是GRUB" class="headerlink" title="1. 什么是GRUB"></a>1. 什么是GRUB</h2><ul><li>简单来说<code>GRUB</code>就是电脑开机过后运行的第一个程序，它负责加载操作系统内核并且将当前系统的控制权移交给操作系统内核。<a id="more"></a>详细信息参见<code>GRUB</code>的文件。</li></ul><h2 id="2-关于版本"><a href="#2-关于版本" class="headerlink" title="2. 关于版本"></a>2. 关于版本</h2><ul><li><code>GRUB2</code>是将<code>GRUB</code>完全重构后的版本，所以又将之前版本的<code>GRUB</code>称为<code>GRUB Legacy</code></li><li><code>GRUB Legacy</code>的最后一个版本为: <code>0.97</code>，即<code>0.97</code>之后的版本均为<code>Grub2</code>,目前<code>GRUB Legacy</code>已经不再做开发了，只进行相关<code>bug</code>的修复，以保证一些旧的系统任然能够使用<code>GRUB Legacy</code></li><li><code>GRUB2</code>的版本是从<code>1.90</code>开始，目前已经到了<code>2.04</code>,它与<code>GRUB Legacy</code>有许多相同的特性，具体的差异见下一小节。</li></ul><h2 id="3-GRUB2与GRUB-Legacy的差异"><a href="#3-GRUB2与GRUB-Legacy的差异" class="headerlink" title="3. GRUB2与GRUB Legacy的差异"></a>3. GRUB2与GRUB Legacy的差异</h2><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.gnu.org/software/grub/" target="_blank" rel="noopener">项目地址</a></li><li><a href="https://www.gnu.org/software/grub/manual/legacy/index.html#Top" target="_blank" rel="noopener">grub legacy文档</a></li><li><a href="https://www.gnu.org/software/grub/manual/grub/grub.html" target="_blank" rel="noopener">grub2文档</a></li><li><a href="https://alpha.gnu.org/gnu/grub/" target="_blank" rel="noopener">镜像地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      简单来说GRUB就是电脑开机过后运行的第一个程序，它负责加载操作系统内核并且将当前系统的控制权移交给操作系统内核。
    
    </summary>
    
      <category term="linux" scheme="https://blog.silverlaw.top/categories/linux/"/>
    
    
      <category term="Linux" scheme="https://blog.silverlaw.top/tags/linux/"/>
    
      <category term="GRUB" scheme="https://blog.silverlaw.top/tags/grub/"/>
    
      <category term="GRUB2" scheme="https://blog.silverlaw.top/tags/grub2/"/>
    
  </entry>
  
  <entry>
    <title>主引导记录MBR</title>
    <link href="https://blog.silverlaw.top/2019/08/14/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95MBR/"/>
    <id>https://blog.silverlaw.top/2019/08/14/主引导记录MBR/</id>
    <published>2019-08-14T07:38:26.000Z</published>
    <updated>2019-08-16T01:35:50.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是MBR"><a href="#1-什么是MBR" class="headerlink" title="1. 什么是MBR"></a>1. 什么是MBR</h2><ul><li>主引导记录（<code>Master Boot Record</code>，缩写：<code>MBR</code>），又叫做主引导扇区，是计算机开机后访问硬盘时所必须要读取的首个扇区，它在硬盘上的三维地址为（柱面，磁头，扇区）＝（0，0，1）。<a id="more"></a>参见<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95" target="_blank" rel="noopener">维基百科</a></li></ul><h2 id="2-MBR说明"><a href="#2-MBR说明" class="headerlink" title="2. MBR说明"></a>2. <code>MBR</code>说明</h2><h3 id="2-1-结构"><a href="#2-1-结构" class="headerlink" title="2.1 结构"></a>2.1 结构</h3><ul><li>主引导扇区记录着硬盘本身的相关信息以及硬盘各个分区的大小及位置信息，是数据信息的重要入口,它位于硬盘的第一个扇区，即硬盘的前<code>512</code>个字节。这<code>512</code>字节又分为三个部分：<code>启动代码</code>、<code>硬盘分区表</code>、<code>结束标志字</code>。</li><li>启动代码： 硬盘的第 1-446 字节 (共<code>446</code>字节)</li><li>硬盘分区表: 硬盘的第 447-510 字节 (共64字节)</li><li>结束标志字: 硬盘的第 511-512 字节 (共2字节)，为 <code>0x55</code> 和 <code>0xAA</code></li></ul><h3 id="2-2-启动代码"><a href="#2-2-启动代码" class="headerlink" title="2.2 启动代码"></a>2.2 启动代码</h3><ul><li>主引导记录最开头是第一阶段引导代码。其中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序（如GNU GRUB）。它不依赖任何操作系统，而且启动代码也是可以改变的，从而能够实现多系统引导。</li></ul><h3 id="2-3-硬盘分区表"><a href="#2-3-硬盘分区表" class="headerlink" title="2.3 硬盘分区表"></a>2.3 硬盘分区表</h3><ul><li>硬盘分区表共<code>64</code>字节，又分为<code>4</code>项,每项<code>16</code>字节。故我们在对系统进行分区时，最多只能划分<code>4</code>个主分区或者<code>3</code>个主分区+<code>1</code>个扩展分区。</li></ul><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://wiki.osdev.org/MBR_(x86)" target="_blank" rel="noopener">https://wiki.osdev.org/MBR_(x86)</a></li><li><a href="https://en.wikipedia.org/wiki/Master_boot_record" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Master_boot_record</a></li></ul>]]></content>
    
    <summary type="html">
    
      主引导记录（Master Boot Record，缩写：MBR），又叫做主引导扇区，是计算机开机后访问硬盘时所必须要读取的首个扇区，它在硬盘上的三维地址为（柱面，磁头，扇区）＝（0，0，1）。
    
    </summary>
    
      <category term="linux" scheme="https://blog.silverlaw.top/categories/linux/"/>
    
    
      <category term="MBR" scheme="https://blog.silverlaw.top/tags/mbr/"/>
    
      <category term="Linux" scheme="https://blog.silverlaw.top/tags/linux/"/>
    
  </entry>
  
</feed>
